00. 프로그래밍 패러다임
- 객체지향 패러다임이 제시하는 '프로그래밍 패러다임'을 설명하기 위한 책
- 객체지향 프로그래밍을 할 때 유사한 생각을 할 수 있는 기반 제공을 목표로하고 있다.
- 프로그래밍 패러다임은 형멱적(revolutionary)이 아니라 발전적(evolutionary)이다.

01. 객체. 설계
- 설계의 목표는 객체 사이의 '결합도'를 낮춰 '변경을 용이'하게 하는 것
  → 캡슐화 : 데이터와 기능을 객체 내부로 함께 묶는 것
	객체의 자율성을 높이고 응집도 높은 객체들의 공동체 창조를 가능하게 함
	데이터와 프로세스가 동일한 모듈 내에 있도록 프로그래밍(객체지향 프로그래밍)을 하여 구현한다.
- 의인화 : 능동적이고 자율적인 존재로 소프트웨어 객체를 설계하는 원리
- 설계한 코드를 배치하는 것, 좋은 설계란 1. 기능 구현 2. 수정 용이 해야한다.

02. 객체지향 프로그래밍
- 프로그래밍하는 동안 집중해야할 두가지
1. 클래스보다 객체를 우선적으로 고려하라.
  클래스는 '공통적'인 상태와 행동을 고려하는 객체를 추상화 한 것
2. 객체를 협력체의 일원으로 고려하라.

객체의 모양 잡기 → 공통된 특성을 가진 객체들을 타입으로 분류 → 타입을 기반으로 클래스 구현

- 도메인 (domain) : 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야

- 객체지향 프로그램이 강력한 이유는 요구사항과 프로그램을 
   '객체'라는 '동일한 관점'에서 바라볼 수 있기 때문이다.
  → 프로그램의 구조 이해와 예상이 쉬움

- 클래스를 구현할 때 중요한 것 → 내부와 외부의 구분 (자율성)
  캡슐화
  접근 제어 : 외부에서의 접근을 통제
  퍼블릭 인터페이스(public interface) : 외부에서 접근가능한 부분
  구현 (implementation) : 내부에서만 접근 가능한 부분

클래스 작성자 (class creator) : 새로운 데이터 타입을 프로그램에 추가
클라이언트 프로그래머 (client programmer) : 작성자가 추가한 데이터 타입 사용
구현 은닉 (implementation hiding) : 내부와 외부의 분리로 서로 간섭을 줄임
  → 프로그램 사용을 위해 알아야하는 지식의 양 감소, 변경이 용이해짐

TEMPLATE METHOD : 부모 클래스에서 기본적인 알고리즘의 흐름을 구현하고 
                 중간에 필요한 처리를 자식 클래스에 위임하는 디자인

* 오버라이딩 (overriding) : 부모클래스에서 정의된 같은 이름, 같은 파라미터를
                           가진 메서드를 자식 클래스에서 재정의 하는 것
                            외부에서는 부모클래스의 메서드를 볼 수 없게된다.
  오버로딩 (over loading) : 메서드의 이름은 같지만 제공되는 파라미터의 목록이 다름
                         부모클래스와 자식클래스에 각각의 메서드가 공존한다.

- 코드의 의존성과 실행 시점의 의존성이 다를 수 있음
  → 코드 이해가 어려워짐 그러나 코드의 유연성과 확장성이 증가함

- 상속 : 클래스 사이의 관계설정만으로 기존의 클래스가 가지고 있는 모든 속성과
          행동들을 새로운 클래스에 포함시킬 수 있음
            슈퍼클래스(superclass) - 서브클래스(subclass)
            기반클래스(base class) - 파생클래스(derived class)
   → 부모클래스와 자식클래스는 '동일한 인터페이스'를 가지고 있기 때문에
       '동일한 메시지'를 수신할 수 있다.

- 업캐스팅(upcasting) : 자식클래스가 부모클래스를 대신하는 것
- 다형성 : 동일한 메세지를 전송해도 메세지를 수신하는 객체의 클래스에 따라
             실행되는 메서드가 달라지는 것
         ** 컴파일시간 의존성과 실행시간 의존성이 다를 수 있다는 사실에 기반함
              메세지와 메서드를 실행시점에 바인딩하는 것으로 구현된다.
              (= 지연바인딩(lazy binding), 동적바인딩(dynamic binding) )
            vs 컴파일 시점에 실행될 함수나 프로시저를 결정하는 것
              (= 초기바인딩(early binding), 정적바인딩(static binding) )

* 구현상속(implementation inheritance) : 순수하게 코드 재사용 목적의 상속
  (= 서브클래싱 (subclassing) )
   인터페이스 상속(interface inheritance) : 다형적인 협력을 위해 부모클래스와
                                           자식클래스의 인터페이스를 공유하는 상속
  (= 서브타이핑 (subtyping) )
  → 구현상속보다 인터페이스 상속을 사용해야한다.

- 추상화의 장점
1. 세부적인 내용을 무시하고 상위정책을 간단하게 표현 가능하다.
   기본적인 애플리케이션의 협력 흐름을 기술하는 것
    → 협력 흐름을 재사용 가능한 설계
2. 기존 구조를 수정하지 않고 새로운 기능을 확장, 추가가 용이하다.

- 합성(composition) : 다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 
                             재사용 하는 것
                             인터페이스에 정의된 메세지를 통해서만 재사용한다.
                               → 상속의 단점 두가지를 해결
                                  1. 캡슐화 위반 2. 유연하지 못한 설계

03. 역할. 책임. 협력
- 책임 : 어떤 객체가 어떤 요형에 대해 대답해줄 수 있거나, 적절한 행동을 할 의무가
  	    있는 경우 해당 객체가 책임을 가진다고 말한다.
        책임을 구현하는 것보다 할당하는 것이 훨씬 중요하다.
	   책임은 객체에 의해 정의되는 응집도있는 행위의 집합으로, 객체가 알아야하는
	   정보와 객체가 수행할 수 있는 행위에 대해 개략적으로 서술한 문장이다.
	   책임의 두가지 범주
	    a) 하는 것 (doing)
		객체를 생성하거나 계산을 하는 등의 스스로 하는것
		다른 객체의 행동을 시작시키는 것
		다른 객체의 활동을 제어하고 조절하는 것
	    b) 아는 것 (knowing)
		개인적인 정보에 관해 아는 것
		관련된 객체에 대해 아는 것
		자신이 유도하거나 계산할 수 있는 것에 관해 아는 것
           → 책임은 객체의 외부에 제공해줄 수 있는 서비스(하는 것의 측면)의 목록과
              제공해줄 수 있는 정보(아는 것의 측면)의 목록이다.
           책임은 객체가 협력에 참여하기 위해 수행해야하는 행위를 상위 수준에서
            개략적으로 서술한 것으로, 일반적으로 하나의 책임은 여러 메세지로 분할된다.

* CRC카드
후보(Candidate), 책임(Responsibility), 협력자(Collaborator)
하나의 CRC카드에는 하나의 후보(역할, 객체, 클래스 등이 해당)가 포함된다.
이름과 목적 (후보가 외부에 제공해야하는 서비스)를 기술한다.
(뒷면) 좌측하단에는 목적을 좀 더 세분화하여 책임을 적는다.
        우측하단에는 책임을 수행하면서 함께할 협력자들을 나열한다.
객체지향 설계에 적용가능한 효과적인 방법이다

- 책임주도설계 (Responsibility-Driven Design)
시스템이 사용자에게 제공해야하는 기능인 시스템 책임을 파악한다
시스템 책임을 더 작은 책임으로 분할한다.
분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다.
객체가 책임을 수행하는 중에 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체또는 역할을 찾는다.
해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게한다.
→ 책임주도설계는 개별적인 객체가 아니라 객체의 책임과 상호작용에 집중한다.

- 메세지가 객체를 결정하는 것의 장점
1. 객체가 최소한의 인터페이스를 가지게 된다. → 캡슐화
2. 충분히 추상적인 인터페이스를 가지게 된다. → 추상화

- 역할 : 다른 것으로 교체할 수 있는 책임의 집합

*역할의 구현
추상클래스 : 책임의 일부를 구현해놓은 것
인터페이스 : 구현없이 책임의 집합만을 나열한 것

협력에 적합한 책임을 수행하는 대상이 한 종류라면 객체로 간주한다.
 이후 책임에 유사성이 보이는 객체들을 묶어 역할로 대체한다.
역할은 객체의 추상화로 볼 수 있다 → 추상화의 장점 적용 가능
연극(책임) 안에서 배역(역할)을 연기하는 배우(객체)
객체는 다양한 역할을 가질 수 있지만 특정 협력에서 하나의 역할로 보이게 된다.