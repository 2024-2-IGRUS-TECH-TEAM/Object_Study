07. 객체 분해
인지과부화
: 문제 해결에 필요한 요소의 수가 단기 기억의 용량을 초과하는 순간 문제 해결 능력은 급격하게 감소
 인지 과부화를 방지하는 가장 좋은 방법 → 단기 기억 안에 보관할 정보(한 번에 기억할 정보)의 양 조절

추상화
: 불필요한 정보를 제거하고 현재의 문제 해결에 필요한 핵심만 남기는 작업
분해
: 큰 문제를 해결 가능한 작은 문제로 나누는 작업
 
"한번에 단기 기억에 담을 수 있는 추상화의 수에는 한계가 있지만 추상화를 더 큰 규모의 추상화로 압축
시킴으로써 단기 기억의 한계를 초월할 수 있다. 따라서 추상화와 분해는 인간이 세계를 인식하고 반응하기
위해 사용하는 가장 기본적인 사고 도구라고 할 수 있다." - p.217
→ 추상화는 기억의 한계를 초월하는, 가장 기본적인 사고 도구

프로그래밍 패러다임
: 추상화가 프로그래밍 언어를 통해 표현되고 발전되며 다양해짐
 프로그래밍을 구성하기 위해 사용되는 추상화의 종류와 
 이 추상화를 이용해 소프트웨어를 분해하는 방법으로 결정됨
 → 모든 프로그래밍 패러다임은 추상화와 분해의 관점에서 설명 가능
 적절한 추상화의 윤곽을 따라 시스템을 어떤식으로 나눌 것인지를 결정하는 원칙과 방법의 집합

현대적인 프로그래밍 언어를 특징짓는 중요한 추상화 매커니즘
두 매커니즘으로 시스템의 분해방법을 설명한다.
1. 프로시저 추상화 (procedure abstraction) → 데이터 조작을 추상화
: 소프트웨어가 무엇을 해야하는지를 추상화
 기능 분해 (functional decomposition) = 알고리즘 분해 (algorithmic decomposition)

2. 데이터 추상화 (data abstraction) → 정보 표현을 추상화
: 소프트웨어가 무엇을 알아야하는지를 추상화
 타입 추상화 (type abstraction) → 추상 데이터 타입 (Abstract Data Type)
 프로시저 추상화 (procedure abstraction) → 객체지향 (Object-Oriented)
 기능을 "협력하는 공동체"를 구성하도록 객체들로 나누는 과정이 객체지향 패러다임에서의 분해를 의미

"프로그래밍 언어의 관점에서 객체지향이란 데이터를 중심으로 데이터 추상화와 프로시저 추상화를 
통합한 객체를 이용해 시스템을 분해하는 방법이다. 그리고 이런 객체를 구현하기 위해 대부분의
객체지향 언어는 클래스라는 도구를 제공한다. 따라서 프로그래밍 언어적 관점에서 객체지향을 바라보는 일반적인 관점은 데이터 추상화와 프로시저 추상화를 함께 포함한 클래스를 이용해 시스템을 
분해하는 것이다" - p.218

객체지향이 전통적인 기능 분해 방법에 비해 효과적이라고 말하는 이유
1. 전통적인 방법 ; 기능 분해 = 알고리즘 분해
: 추상화의 단위는 프로시저, 시스템은 프로시저를 단위로 분해된다.

- 프로시저
 : 반복적으로 실행되거나 거의 유사하게 실행되는 작업들을 하나의 장소에 모아놓음으로써 로직을
  재사용하고 중복을 방지할 수 있는 추상화 방법
  추상화라고 부르는 이유는 내부의 상세한 구현 내용을 몰라도 인터페이스만 알면 사용가능하기 때문
  프로시저만으로 효과적인 정보은닉 체계를 구축하는데는 한계 존재
 기능 분해 관점에서 시스템은 "필요한 더 작은 작업으로 분해될 수 있는 하나의 커다란 메인함수"이다.

- 하향식 접근법
 : 전통적인 기능 분해 방법은 하향식 접근법을 따른다
  시스템을 구성하는 가장 최상위 기능을 정의하고 이 기능을 좀 더 작은 단계의 하위 기능으로 분해해
  나가는 방법
 기본적으로 기능 분해는 책의 목차를 정리하고 그 안에 내용을 채워 넣는 것과 유사하다.

- 기능 분해 방법의 문제 ; 유지보수, 변경에 취약하다.
: 시스템은 하나의 메인함수로 구성되어 있지 않다.
 → 모든 기능들은 규모의 측면에서 차이가 있을 수 있지만 기능성의 측면에서 동등하게 독립적이다.
 기능 추가나 요구사항 변경으로 인해 메인 함수를 빈번하게 수정해야 한다.
 → 하나의 최고점(정상)은 존재하지 않는다. 따라서 새기능을 추가할 때마다 메인함수를 수정해야 한다.
 비즈니스 로직이 사용자 인터페이스와 강하게 결합된다.
 → 사용자 인터페이스는 시스템 내에서 가장 자주 변경되는 부분, 그에 비해 비즈니스 로직 변경은 적다.
 하향식 분해는 너무 이른 시기에 함수들의 실행 순서를 고정시켜서 유연성과 재사용성이 저하된다.
 → 기존 로직과는 아무런 상관이 없는 새함수의 적절한 위치를 확보하기 어렵다.
 데이터 형식이 변경될 경우 파급효과를 예측할 수 없다.
 → 어떤 데이터를 어떤 함수가 사용하고 있는지 추적하기 어렵다.

- 하향식 분해가 유용한 경우
: 설계가 어느정도 안정화된 후에는 설계의 다양한 측면을 논리적으로 설명하고 문서화하기에 용이함
 이미 완전히 이해된 사실(이미 해결된 알고리즘)을 서술하기에 적합한 방법

2. 정보은닉과 모듈
: 기능 분해 방식의 문제를 해결하기 위해 "정보 은닉"과 "모듈"이라는 개념을 제시
 시스템을 모듈 단위로 분해하기 위한 기본 원리
 외부에 감춰야 하는 비밀에 따라 시스템을 분할하는 모듈 분할 원리이다.
 모듈은 변경될 가능성이 있는 비밀을 내부로 감추고, 쉽게 변경되지 않을 퍼블릭 인터페이스를
  외부에 제공해서 내부의 비밀에 함부로 접근하지 못하게 한다.
 시스템을 모듈로 분해한 후 각 모듈 내부를 구현하기 위해 기능 분해를 적용할 수 있다.(배타적이지 않음)

- 모듈이 감춰야 하는 비밀
복잡성 
: 외부에 모듈을 추상화할 수 있는 간단한 인터페이스를 제공해서 모듈의 복잡도를 낮춘다.
변경 가능성 
: 변경 발생 시 하나의 모듈만 수정하면 되도록 변경 가능한 설계 결정을 모듈 내부로 감추고 
 외부에는 쉽게 변경되지 않은 인터페이스를 제공한다.

- 모듈의 장점
: 모듈 내부의 변수가 변경되더라도 모듈 내부에만 영향을 미친다.
 → 데이터 변경으로 인한 파급효과를 제어할 수 있어 코드 수정과 디버깅에 용이함
 비즈니스 로직과 사용자 인터페이스에 대한 관심사를 분리한다.
 전역 변수와 전역 함수를 제거함으로써 네임스페이스 오염을 방지한다.
 모듈은 기능이 아니라 변경의 정도에 따라 시스템을 분해하기 때문에
  각 모듈은 관련성 높은 데이터와 함수의 집합이다.
 → 모듈 내부는 높은 응집도를, 모듈과 모듈 사이에는 낮은 결합도를 유지한다.

- 모듈의 단점
: 인스턴스의 개념을 제공하지 않는다.
  → 좀 더 높은 수준의 추상화를 위해서 각 인스턴스를 독립적인 단위로 다룰 수 있어야 함. (표현력 한계)

3. 추상 데이터 타입
: 모듈의 인스턴스 부재를 충족시키기 위해 등장한 개념
 프로그래밍 언어가 제공하는 타입처럼 동작하는 사용자 정의 타입을 추가할 수 있게 하는 것
 
- 타입
: 변수에 저장할 수 있는 내용물의 종류와 변수에 적용될 수 있는 연산의 가짓수를 의미한다.
 저장된 값에 대해 수행될 수 있는 연산의 집합을 결정하기 때문에 변수의 값이 어떻게 행동할 것
  이라는 것을 예측할 수 있게 한다.

- 추상 데이터 타입 구현을 위해 지원이 필요한 프로그래밍 언어의 특성 (오퍼레이션 클러스터)
: 타입 정의를 선언할 수 있어야 한다.
 타입의 인스턴스를 다루기 위해 사용할 수 있는 오퍼레이션의 집합을 정의할 수 있어야 한다.
 제공된 오퍼레이션을 통해서만 조작할 수 있도록 데이터를 외부로부터 보호할 수 있어야 한다.
 타입에 대해 여러 개의 인스턴스를 생성할 수 있어야 한다.

- 클래스는 추상 데이터 타입인가 ? ************ P.245
: 클래스는 상속과 다형성을 지원하는 데 비해 추상 데이터 타입은 그러지 못한다는 점이 큰 차이점.

09. 유연한 설계
유연하고 재사용 가능한 설계를 위해 적용할 수 있는 다양한 의존성 관리 기법들을 
원칙이라는 관점에서 정리, 설계를 논의할 때 사용할 수 있는 공통의 어휘를 익힌다.

1. 개방-폐쇄 원칙 (Open-Closed Principle, OCP)
: "소프트웨어 개체는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야한다."
 확장에 대해 열려 있다 : 요구사항이 변경될 때 새로운 '동작'을 추가해 기능을 확장 할 수 있다.
 수정에 대해 닫혀 있다 : 기존의 '코드'를 수정하지 않고도 동작을 추가하거나 변경할 수 있다.

- 컴파일타임 의존성을 고정시키고 런타임 의존성을 변경하라
: 컴파일타임 의존성 : 코드에서 드러나는 클래스들 사이의 관계
 런타임 의존성 : 실행시에 협력에 참여하는 객체들 사이의 관계
 ex. 새로운 클래스를 추가하는 것만으로 기능을 확장하는 예시
 → 클래스 사이의 의존성(컴파일타임 의존성)은 유지되고, 런타임 의존성은 변경됨

- 추상화가 핵심이다 (추상화에 의존하라)
: 추상화를 사용하면 문맥에 따라 변하지 않는 부분은 남고, 변하는 부분은 생략됨
  → 남겨지는 공통적인 부분은 수정에 대해 닫혀있고, 생략된 부분은 확장에 대해 열려 있다.
 ex. 추상화 된 클래스(변하지 않는 부분)에 대해서만 의존하는 클래스의 예시
 → "추상화는 확장을 가능하게 하고 추상화에 대한 의존은 폐쇄를 가능하게 한다."
* 수정에 대해 닫혀있는 클래스에만 의존한다면, 그 클래스도 수정에 대해 닫혀 있게 됨
 변경에 의한 파급효과를 최대한 피하기 위해서는 올바른 추상화를 주의깊에 선택해야 한다.

2. 생성 사용 분리 (separation use from creation)
: "소프트웨어 시스템은 (응용 프로그램 객체를 제작하고 의존성을 서로 "연결"하는) 시작 단계와
 (시작 단계 이후에 이어지는) 실행 단계를 분리해야 한다.

- FACTORY 추가하기
: 객체 생성과 관련된 지식이 협력하는 클라이언트에게까지 새어나가기를 원하지 않을 때,
  객체 생성과 관련된 책임만 전담하는 객체인 FACTORY를 사용하도록 만들 수 있다.
 → 객체를 사용하는 클래스에게 생성에 관한 지식을 전달하지 않을 수 있다.

- 순수한 가공물에게 책임 할당하기
: 책임을 수행하는 데 필요한 정보를 가장 많이 알고 있는 INFORMATION EXPERT에게 책임을 할당
 전체적으로 결합도를 낮추고 재사용성을 높이기 위해 도메인 개념에게 할당되어 있던 책임을 
  아무런 상관이 없는 가공의 객체로 이동시키는 것
 시스템을 객체로 분해하는 방식
  - 표현적 분해 
	: 도메인에 존재하는 사물 또는 개념을 표현하는 객체들을 이용해 시스템을 분해하는 것
	 도메인과 소프트웨어 사이의 표현적 차이를 최소화하는 것을 목적
  - 행위적 분해
	: 모든 책임을 도메인 객체에게 할당하면 생기는 문제점을 해결하기 위해 도메인과 무관한
	  인공적인 객체(PURE FABRICATION)을 추가해 책임을 할당하는 것
	 오히려 인공적인 객체들이 더 많은 비중을 차지하는 것이 일반적
	 실세계의 모방을 걱정하지 말고 사용자들이 원하는 기능을 제공하기 위해 주저하지 말 것
 PURE FABRICATION은 INFORMATION EXPERT 패턴에 따라 책임을 할당한 결과가 바람직하지 않을
  경우 대안으로 사용된다.

3. 의존성 주입 *********** p.293
: 객체가 아닌 외부의 독립적인 객체가 인스턴스를 생성한 후 이를 전달해서 의존성을 해결하는 방법
 외부에서 의존성의 대상을 해결한 후 이를 사용하는 객체 쪽으로 주입한다.

 의존성을 해결하기 위해 의존성을 객체의 퍼블릭 인터페이스에 명시적으로 드러내서 외부에서 필요한
  런타임 의존성을 전달할 수 있도록 만드는 방법을 포괄하는 명칭이기 때문에 별도의 용어가 정의됨
 - 생성자 주입 (constructor injection) ㅁ: 객체를 생성하는 시점에 생성자를 통한 의존성 해결 
 - setter 주입 (setter injection) : 객체 생성 후 setter 메서드를 통한 의존성 해결
 - 메서드 주입 (method injection) : 메서드 실행 시 인자를 이용한 의존성 해결

- SERVICE LOCATOR 패턴
: 의존성을 해결할 객체들을 보관하는 일종의 저장소, 
  객체가 직접 SERVICE LOCATOR에게 의존성을 해결해줄 것을 요청한다.
 의존성을 감추는 문제점이 발생 
 → 의존성이 어디에서 발생하는지 알기 어려움
 → 캡슐화 위반, 클래스의 사용법을 익히기 위해 구현 내부를 뒤져야 한다면 캡슐화가 무너진 것
 → 의존성의 대상을 설정하는 시점과 의존성이 해결되는 시점이 멀어짐, 코드 이해와 디버깅이 어려워짐
 의존성 주입은 이러한 문제를 해결함. 
  객체의 캡슐을 단단하게 보호하고 의존성도 컴파일타임에서 해결가능
 의존성 주입이 더 좋다는 이야기는 아님. 핵심은 "명시적인 의존성이 좋다".

4. 의존성 역전 원칙
: 상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안된다. 둘 모두 추상화에 의존해야 한다.
 추상화는 구체적인 사항에 의존해서는 안 된다. 구체적인 사항은 추상화에 의존해야 한다.
 → 의존성의 방향이 전통적인 절차형 프로그래밍과 반대 방향으로 나타나기 때문에 '역전'이라 명명

 객체 사이의 협력이 존재할 때 그 협력의 본질을 담고 있는 것은 상위 수준의 정책
 그러나 이런 상위 수준의 클래스가 하위 수준의 클래스에 의존한다면 변경에 취약해질 것임.
  → 해결 방법은 추상화, 추상화에 의존하도록 수정하면 재사용성과 변경에 취약한 점을 모두 해결 가능

- 의존성 역전 원칙과 패키지
: 인터페이스의 소유권에도 역전이 적용된다.
 같은 패키지 안에 존재하는 불필요한 클래스들은 전체적인 빌드 시간을 상승시킴.
 
- SEPARATED INTERFACE 패턴
: 추상화를 클라이언트가 속한 패키지에 포함시키고, 
 패키지에 포함된 함께 재사용 되지 않는 클래스들은 별도의 독립적인 패키지에 모으는 기법
 
의존성 역전 원칙에 따라 상위 수준의 협력 흐름을 재사용하기 위해서는 
 추상화가 제공하는 인터페이스의 소유권 역시 역전시켜야 한다.
 잘 설계된 객체지향 애플리케이션에서는 인터페이스의 소유권을 서버가 아닌 클라이언트에 위치시킨다.
  → 객체지향 프레임워크의 모듈 구조를 설계하는 데 가장 중요한 핵심 원칙

5. 유연성에 대한 조언
- 유연한 설계는 유연성이 필요할 때만 옳다.
: 설계의 미덕은 단순함과 명확함으로부터 나온다. 유연성을 위해서 이 둘을 버리게 될 가능성이 높다.
 유연성은 항상 복잡성을 수반한다. 불필요한 유연성은 불필요한 복잡성을 낳는다.

- 협력과 책임이 중요하다.
: 객체의 역할과 책임이 자리를 잡기 전에 너무 성급하게 객체 생성에 집중하지 마라
 책임 할당과 협력의 균형을 맞추는 것이 객체 생성에 관한 책임 할당보다 우선이다.
 의존성을 관리해야하는 이유는 역할, 책임 협력의 관점에서 설계가 유연하고 재사용 가능해야 하기 때문
 역할, 책임, 협력의 모습이 선명하지 않다면 의존성 관리에 들인 노력이 물거품이 될 수도 있다.


