04. 설계 품질과 트레이드오프 (어느 것을 얻으려면 반드시 다른 것을 희생하여야 하는 관계)
"객체지향 설계란 올바른 객체에게 올바른 책임을 할당하면서 낮은 결합도와 높은 응집도를 가진 구조를 창조하는 활동이다" - p.97

"설계는 변경을 위해 존재하고, 변경에는 무조건적으로 비용이 발생하기 때문에 
훌륭한 설계란 합리적인 비용 안에서 변경을 수용할 수 있는 구조로 만드는 것이다." - p.97
→ 이 구조를 유지할 수 있는 중요한 원칙은 객체의 '행동'에 초점을 맞추는 것

객체의 상태는 구현에 속하기 때문에 상태를 객체 분할의 중심축으로 삼으면 구현이 인터페이스에 스며들게 된다.
상태는 변경되기 쉽고, 이는 인터페이스의 변경을 초래하며 인터페이스와 연관된 모든 객체에게 영향을 주게된다.
결과적으로 변경에 취약해진다.
객체의 책임은 인터페이스에 속하기 때문에 인터페이스 뒤로 상태를 캡슐화함으로써 구현 변경에 대한 파장이 외부에 전달되지 않게 한다.
내부의 데이터를 반환하는 접근자와 데이터를 변경하는 수정자를 추가하는 방식이 사용된다.

세가지 품질척도
1. 캡슐화
변경의 관점에서 설계의 품질을 판단하기 위해 캡슐화를 기준으로 삼을 수 있다.
2. 응집도 : 모듈에 포함된 내부 요소들이 연관돼 있는 정도 
→ 변경이 발생할 때 모듈 내부에서 발생하는 변경의 정도
 변경이 적게 발생할 수록, 응집도가 높다고 할 수 있다.
3. 결합도 : 의존성의 정도를 나타내며 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지를 나타내는 척도
→ 한 모듈이 변경되기 위해서 다른 모듈의 변경을 요구하는 정도
 변경해야하는 모듈의 수가 늘어날 수록 결합도가 높다고 할 수 있다.
어떤 설계를 쉽게 변경할 수 있다면 높은 응집도를 가진 요소들 사이의 결합도가 낮을 확률이 높다.

- 추측에 의한 설계 전략 
: 접근자와 수정자에 과도하게 의존하는 설계 방식
 객체가 사용될 협력을 고려하지 않고, 객체가 다양한 곳에서 사용될 수 있을 것이라는 
 막연한 추측을 기반으로 설계한다.
 그 결과, 내부 상태를 드러내는 메서드를 최대한 많이 추가하게 되며 
 캡슐화의 원칙을 위반한 설계를 하게된다.

- 단일 책임 원칙 
: 클래스는 단 한가지의 변경 이유만 가져야 한다는 원칙
 아무런 관련이 없는 코드가 하나의 모듈에 뭉쳐져 있다면 변경에 취약할 것이다.

- 캡슐화의 진정한 의미 
: 구현과 관련된 변할 수 있는 어떤 것이라도 감추는 것
 내부 구현의 변경으로 인해 외부의 객체가 영향을 받는다면 캡슐화를 위반한 것이다.

05. 책임 할당하기
동일한 문제를 해결할 수 있는 다양한 책임 할당 방법이 존재, 
올바른 책임을 할당하기 위해서는 다양한 관점에서 설계를 평가할 수 있어야 한다.

데이터 중심의 설계에서 책임 중심의 설계로 전환하기 위해서 따라야할 두가지 원칙
1. 데이터보다 행동을 먼저 결정하라
: 데이터에 초점을 맞추면 변경에 취약한 설계를 하게된다.
2. 협력이라는 문맥 안에서 책임을 결정하라
: 협력에 어울리는 책임을 할당하기 위해서는 메시지를 결정한 후 메시지를 처리할 객체를 결정해야 한다.
→ 책임 주도 설계 방법의 핵심과 거의 동일함

GRASP 패턴
: 객체에게 책임을 할당할 때 지침으로 삼을 수 있는 원칙들의 집합을 패턴 형식으로 정리한 것
 도메인개념에서 출발하기
 : 구현을 가이드할 수 있는 도메인 모델을 선택하라.
  설계에 필요한 용어를 제공하는 것을 넘어 코드의 구조에도 영향을 미친다.

1. INFORMATION EXPERT (정보전문가) 패턴
: 책임을 수행할 정보를 알고 있는 객체에게 책임을 할당하는 것
 필요한 정보를 가진 객체들로 책임이 분산되기 때문에 높은 응집도를 실현할 수 있고,
 결과적으로 결합도가 낮아져서 유지보수하기 쉬운 시스템을 구축할 수 있다.
 정보전문가가 데이터를 반드시 저장하고 있을 필요는 없다.
 '객체란 상태와 행동을 함께 가지는 단위'라는 객체지향의 기본적인 원리를 책임 할당의 관점에서 표현

2. LOW COUPLING (낮은 결합도) 패턴
: 설계의 전체적인 결합도가 낮게 유지되도록 책임을 할당하라

3. HIGH COHESION (높은 응집도) 패턴
: 높은 응집도를 유지할 수 있는 설계를 선택하라

4. CREATOR (창조자) 패턴
: 객체를 생성할 책임을 어떤 객체에게 할당할지에 대한 지침을 제공한다.
 아래 조건을 최대한 많이 만족하는 B에게 A 객체 생성 책임을 할당하라.
 - B가 A 객체를 포함하거나 참조한다.
 - B가 A 객체를 기록한다.
 - B가 A 객체를 긴밀하게 사용한다.
 - B가 A 객체를 초기화하는 데 필요한 데이터를 가지고 있다. (B는 A에 대한 정보전문가이다.)
 생성되는 객체와 연결되거나 관련될 필요가 있는 객체에게 해당 객체를 생성할 책임을 맡기는 것
 이미 존재하는 객체 사이의 관계를 이용하기 때문에 설계가 낮은 결합도를 유지할 수 있게 한다.

변경에 취약한 클래스 개선하기
: 변경에 취약한 클래스란 코드를 수정해야하는 이유를 하나 이상 가지는 클래스를 의미한다.
 → 변경의 이유에 따라 클래스를 분리해야 한다.
 코드를 통해 변경의 이유를 파악할 수 있는 방법
 1. 인스턴스 변수가 초기화되는 시점을 살펴본다.
  : 응집도가 높은 클래스는 인스턴스를 생성할 때 모든 속성을 함께 초기화 시킨다.
    일부만 초기화 되는 경우, 함께 초기화되는 속성을 기준으로 코드를 분리해야 한다.
 2. 매서드들이 인스턴스 변수를 사용하는 방식을 살펴본다.
  : 모든 매서드가 객체의 모든 속성을 사용한다면 클래스의 응집도는 높다고 볼 수 있다.
   메서드들이 사용하는 속성에 따라 그룹이 나뉘는 경우, 
   속성 그룹과 해당 그룹에 접근하는 메서드 그룹을 기준으로 코드를 분리해야 한다.
    
5. POLYMORPHISM (다형성) 패턴
: 객체의 타입에 따라 변하는 행동이 있다면,
 타입을 분리하고 변화하는 행동을 각 타입의 책임으로 할당하라.
 객체의 타입을 검사해서 타입에 따라 여러 대안들을 수행하는 조건적인 논리를 사용하지 말기를 권장

6. PROTECTED VARIATIONS (변경 보호) 패턴
: 변화가 예상되는 지점들을 식별하고 그 주위에 안정된 인터페이스를 형성하도록 책임을 할당하라.
 "설계에서 변하는 것이 무엇인지 고려하고 변하는 개념을 캡슐화하라"

설계를 주도하는 것은 변경이다.
변경에 대비할 수 있는 두가지 방법
1. 코드를 이해하고 수정하기 쉽도록 최대한 단순하게 설계하는 것
2. 코드를 수정하지 않고도 변경을 수용할 수 있도록 코드를 더 유연하게 만드는 것
→ 대부분 전자가 더 좋지만, 유사한 변경이 반복적으로 발생한다면 후자의 방법을 사용
유연성의 정도에 따라 결합도를 조절할 수 있는 능력은 객체지향 개발자가 갖춰야 하는 중요한 기술

리팩터링 (Refactoring)
: 이해하기 쉽고 수정하기 쉬운 소프트웨어로 개선하기 위해 
 겉으로 보이는 동작은 바꾸지 않은 채 내부 구조를 변경하는 것
 아무것도 없는 상태에서 책임과 협력에 관해 고민하기보다는 
 실행되는 코드를 통해 드러나는 책임들을 올바른 위치로 이동시키는 것

몬스터 메서드 (monster method)
: 긴 메서드는 응집도가 낮기 때문에 이해하기도 어렵고 재사용하기도 어려우며 변경하기도 어렵다.
→ 작고 응집도 높은 메서드로 분리하면 각 메서드를 적절한 클래스로 이동시키기 수월해진다.
 또한 전체적인 흐름을 이해하기 쉬워지고, 변경하기도 더 쉽다.

어떤 메서드를 어떤 클래스로 이동시켜야 할까 ? → 객체는 자율적인 존재여야 한다는 사실을 떠올리자
자신이 소유하고 있는 데이터를 스스로 처리하도록 만드는 것이 가장 좋은 방법
따라서 메서드가 사용하는 데이터를 저장하고 있는 클래스로 메서드를 이동시키면 된다.

06. 메시지와 인터페이스
객체지향 애플리케이션의 가장 중요한 재료는 클래스가 아니라 '객체들이 주고받는 메시지'다.
객체가 수신하는 메시지들이 객체의 퍼블릭 인터페이스를 구성한다.
훌륭한 퍼블릭 인터페이스를 얻기위해 도움이되는 설계 원칙과 기법을 익히는 것이 이번 장의 주제다.

"메시지는 객체 사이의 협력을 가능하게 하는 매개체다.
메시지를 매개로하는 요청과 응답의 조합이 두 객체 사이의 협력을 구성한다." - p.176

클라이언트-서버 (Client-Server) 모델
: 협력 안에서 메시지를 전송하는 객체를 클라이언트, 메시지를 수신하는 객체를 서버라고 부른다.
 협력은 클라이언트가 서버의 서비스를 요청하는 단방향 상호작용이다.
 객체는 협력에 참여하는 동안 클라이언트와 서버의 역할을 동시에 수행하는 것이 일반적이다.

* 용어정리
메시지(message) : 객체들이 협력하기 위해 사용할 수 있는 유일한 의사소통 수단
메시지 전송(message sending), 메시지 패싱(message passig):한 객체가 다른 객체에 도움을 요청하는 것
메시지는 '오퍼레이션 명(operation name)'과 '인자(argument)'로 구성되며,
메세지 전송은 여기에 '메시지 수신사(message receiver)'를 추가한 것이다.

메서드(method) 
: 메시지를 수신했을 때 실제로 실행되는 함수 또는 프로시저
 메시지에 응답하기 위해 실행되는 코드 블록
 코드 상에서 동일한 이름의 변수(condition)에게 동일한 메시지를 전송하더라도,
 객체의 타입에 따라 실행되는 메서드가 달라질 수 있다.
 실행 시점에 메시지와 메서드를 바인딩하는 메커니즘은 두 객체 사이의 결합도를 낮춤으로써,
 유연하고 확장 가능한 코드를 작성할 수 있게 만든다.

퍼블릭 인터페이스
: 객체가 의사소통을 위해 외부에 공개하는 메시지의 집합
 오퍼레이션 : 퍼블릭 인터페이스에 포함된 메시지, 객체가 다른 객체에게 제공하는 추상적인 서비스
 "인터페이스의 각 요소는 오퍼레이션이다. 오퍼레이션은 구현이 아닌 추상화다.
  반면 메서드는 오퍼레이션을 구현한 것이다. 메서드는 오퍼레이션에 대한 구현이다."
 메시지 전송 → 오퍼레이션 호출 → 메서드 실행

시그니처
: 오퍼레이션(또는 메서드)의 이름과 파라미터 목록을 합친 것
 오퍼레이션은 실행 코드 없이 시그니처만을 정의한 것, 메서드는 이 시그니처에 구현을 더한 것이다.
 오퍼레이션의 관점에서 다형성이란 동일한 오퍼레이션 호출에 대해 서로 다른 메서드들이 실행되는 것

퍼블릭 인터페이스의 품질에 영향을 미치는 원칙과 기법
1. 디미터 법칙 (Law of Demeter)
: 객체의 내부 구조에 대한 결합으로 인해 발생하는 설계 문제를 해결하기 위해 제안된 원칙
 객체 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하라는 것이다.
 클래스가 특정한 조건을 만족하는 대상에게만 메시지를 전송하도록하여 구현.
 클래스의 캡슐화를 지키기 위해 접근해야 하는 요소를 제한한다.
 기차 충돌 (train wreck) 
 : 메세지 전송자가 수신자의 내부 구조에 대해 물어보고 
  반환 받은 요소에 대해 연쇄적으로 메시지를 전송.
  메시지 전송자는 메시지 수신자의 내부 정보를 자세히 알게되고, 내부 구현에 강하게 결합된다.

2. 묻지 말고 시켜라
: 훌륭한 메시지는 객체의 상태에 관해 묻지 말고 원하는 것을 시키는 스타일을 가져야한다.
 이 원칙을 따르면 객체의 정보를 이용하는 행동을 객체의 내부에 위치시키기 때문에,
 자연스럽게 정보와 행동을 동일한 클래스 안에 두게 된다.

3. 의도를 드러내는 인터페이스
메서드가 작업을 어떻게 수행하는지를 나타내도록 이름 짓기 
→ 내부의 구현 방법을 드러낸다
 이름이 다른 두 메서드가 같은 작업을 수행하는지 알아채기 어려움 + 메서드 수준의 캡슐화 위반
의도를 드러내는 선택자 (Intention Revealing Selector)
: 무엇을 하느냐에 따라 메서드의 이름을 짓는 패턴
 
잊지 말야야 하는 사실은 설계가 트레이드오프의 산물이라는 것이다.
원칙이 현재 상황에 부적합하다고 판단된다면 과감하게 원칙을 무시하라.
원칙을 아는 것보다 더 중요한 것은 언제 원칙이 유용한지 판단할 수 있는 능력을 기르는 것이다.
"경우에 따라 다르다"

4. 명령-쿼리 분리 (Command-Query Separation) 원칙
: 퍼블릭 인터페이스에 오퍼레이션을 정의할 때 참고할 수 있는 지침을 제공
 모든 오퍼레이션은 명령인 동시에 쿼리일 수 없다는 원칙

*용어 정리
루틴(routine) : 어떤 절차를 묶어 호출 가능하도록 이름을 부여한 기능 모듈
루틴은 프로시저와 함수로 구분할 수 있다.
프로시저(procedure) : 부수효과를 발생시킬 수 있지만 값을 반환할 수 없다.
함수(function) : 값을 반환할 수 있지만 부수효과를 발생시킬 수 없다.
명령과 쿼리는 객체의 인터페이스 측면에서 프로시저와 함수를 부르는 또 다른 이름
명령(Command) : 객체의 상태를 수정하는 오퍼레이션
쿼리(Query) :  객체와 관련된 정보를 반환하는 오퍼레이션

컴퓨터와 수학의 세계를 나누는 가장 큰 특징은 부수효과(side effect)다.
프로그램에서 부수효과를 발생시키는 대표적인 문법 두가지는 대입문과 프로시저다.
프로시저는 내부에 부수효과를 포함할 경우, 동일한 인자를 전달하더라도 결괏값이 매번 달라질 수 있다.
참조 투명성
: 어떤 표현식 e가 있을 때 모든 e를 e의 값으로 바꾸더라도 결과가 달라지지 않는 특성
 수학에서 함수는 동일한 입력에 대해 항상 동일한 값을 반환하기 때문에 참조 투명성을 만족한다.
 장점
 1. 모든 함수를 이미 알고 있는 하나의 결괏값으로 대체할 수 있기 때문에 식을 쉽게 계산할 수 있다.
 2. 모든 곳에서 함수의 결괏값이 동일하기 때문에 식의 순서를 변경하더라도 각 식의 결과는 변함없다.\

"객체지향 패러다임이 객체의 상태변경이라는 부수효과를 기반으로 하기 때문에 참조 투명성은 예외에
가깝다. 하지만 명령-쿼리 분리 원칙은 부수효과를 가지는 명령으로부터 부수효과를 가지지 않는 쿼리를
명백하게 분리함으로써 제한적이나마 참조 투명성의 혜택을 누릴 수 있게 된다." - p.213


